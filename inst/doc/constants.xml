<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/Users/duncan/Projects/org/omegahat/Docs/XSL/Rstyle.xsl"?>

<article  xmlns:r="http://www.r-project.org"
          xmlns:c="http://www.C.org"
          xmlns:cpp="http://www.cplusplus.org"
          xmlns:sh="http://www.shell.org"
          xmlns:xi="http://www.w3.org/2001/XInclude">
<invisible>
<r:codeIds>
tu
tuGlobals
real
output
</r:codeIds>
</invisible>

<section>
<title>Constants of Various Types</title>
<para>
In this example, we will look at the wxWidgets code and compute the R
interface to the constants for that library.
</para>

<para>
<r:code id="tu">
autoGenerateDir = "~/Projects/org/omegahat/R/RwxWidgets/autoGenerate"
wx.tu.fileName = paste(autoGenerateDir, "wx.cpp.t00.tu", sep = .Platform$file.sep)
</r:code>

<r:code id="tu">
library(RSPerl)
if(length(grep("linux", R.Version()$platform)))
  xsSupport(c("IO", "Fcntl", "POSIX", "Socket"))
</r:code>

<r:code id="tu">
library(RGCCTranslationUnit)
tu = parseTU.Perl(wx.tu.fileName)
</r:code>
<r:code>
types = DefinitionContainer()
</r:code>
We compute all the global variables with
<r:code>
gvars = getGlobalVariables(tu)
</r:code>
Note that this gives us the variables from all files, not just the
ones in the wxWidgets code.  Unfortunately, GCC doesn't give us the
full file name, so we cannot filter on directory. However, we can
match the names of the source files in the TU file to the list of file
names in the wxWidgets include directories.
<r:code>
topfiles = list.files("/usr/local/include/wx-2.8/wx", recursive = TRUE)
targets = gsub("\\.[^\\.]+$", "", topfiles)
targetFiles = basename(targets)
</r:code>
(Change the directory for the wx include files approriately for your system.)
And we can also find all the files that are included using the -M
flag of gcc/g++ and creating the dependency list. 
<sh:code>
g++ -M `wx-config --cflags` wx.cpp > deps
</sh:code>
<note><para>This used to work but is causing an error because of the
failure to find sql.h and sqlext.h.
I have added a 
<c:code><![CDATA[
#ifdef wxUSE_ODBC
#define wxUSE_BUILTIN_IODBC 1
#include <wx/db.h>
#include <wx/dbkeyg.h>
#include <wx/dbtable.h>
#endif
]]></c:code>
to conditionally include these files. 
The line the defines wxUSE_BUILTIN_IODBC should not be there.
The inclusion of sql.h and sqlext.h in db.h should not
occur if the files aren't present.
</para></note>
We use
<r:func>readDependencies</r:func> to bring these into R
as a named character vector
<r:code>
deps = readDependencies("deps")
</r:code>
And we can use this to find the names of all the files that
we might be interested in. (There may be overlap with a file named, say,
foo in /usr/include and also include/wx and without the path information
in the TU file, we can't distinguish between them without more contextual information.)
<r:code>
wxFiles = grep('wx-2\\.8', deps, value = TRUE)
</r:code>
</para>

<para>
So we can use this in our call to <r:func>getGlobalVars</r:func>
as
<r:code>
gvars = getGlobalVariables(tu, names(wxFiles))
</r:code>
and that eliminates (about) 90 variables that are not part of
wxWidgets.  These include variables such as stdin, environ, optoerr,
timezone and many mangled names from C++. 
<!-- We did have some problems, missing with this but all seems okay now.
 Here are the notes:
 Unfortunately, this seems
to eliminate some and suggests that we need to look at what -M
generates more closely.  (e.g. the variable wxCheckBoxNameStr defined
in tglbtn.h) We are working with a deps file which may be out of sync
with the tu file. So we use the targetFiles 
<r:code>
gvars = getGlobalVariables(tu, targetFiles)
</r:code>
 -->
</para>

<para>
From this collection of global variables, we can find all the constant
ones.  We use <r:func>computeGlobalConstants</r:func> to do this.
Using the <r:arg>varsOnly</r:arg>, we find the the nodes in the TU
file that identify const global variables. 
<r:code>
constVars = computeGlobalConstants(tu, gvars, varsOnly = TRUE, defs = types)
</r:code>
There are 328 of these.
If we look at the names of these variables, we see that they are all
related to wxWidgets
<r:code>
names(constVars) [ - grep("^wx", names(constVars))]
<r:output>
 [1] "DB_GRANT_ALL"            "DB_GRANT_DELETE"        
 [3] "DB_GRANT_UPDATE"         "DB_GRANT_INSERT"        
 [5] "DB_GRANT_SELECT"         "DB_WHERE_MATCHING"      
 [7] "DB_WHERE_KEYFIELDS"      "DB_DEL_MATCHING"        
 [9] "DB_DEL_WHERE"            "DB_DEL_KEYFIELDS"       
[11] "DB_UPD_WHERE"            "DB_UPD_KEYFIELDS"       
[13] "DB_SELECT_STATEMENT"     "DB_SELECT_MATCHING"     
[15] "DB_SELECT_WHERE"         "DB_SELECT_KEYFIELDS"    
[17] "DB_DATA_TYPE_BLOB"       "DB_DATA_TYPE_DATE"      
[19] "DB_DATA_TYPE_FLOAT"      "DB_DATA_TYPE_INTEGER"   
[21] "DB_DATA_TYPE_VARCHAR"    "DB_MAX_COLUMN_NAME_LEN" 
[23] "DB_MAX_TABLE_NAME_LEN"   "DB_MAX_ERROR_HISTORY"   
[25] "DB_MAX_ERROR_MSG_LEN"    "DB_MAX_WHERE_CLAUSE_LEN"
[27] "DB_MAX_STATEMENT_LEN"    "DB_TYPE_NAME_LEN"       
[29] "SQL_CATALOG_FILENAME"    "SQL_LOG_FILENAME"       
</r:output>
</r:code>
The DB_ and SQL_ variables are part of the database classes in wxWidgets.
Indeed, we can find where they are defined with
<r:code>
gvars[["SQL_CATALOG_FILENAME"]]$source()
<r:output>
[1] "db.h:149"
</r:output>
</r:code>
and we can then look at that file and line number to confirm that
this is part of the wxWidgets code.
<note><para>We have to be careful
here to ensure that we are dealing with const variables
and not variables that point to const.</para></note>
</para>

<para>
Without this argument, the <r:func>computeGlobalConstants</r:func>
function returns C/C++ code that can be compiled and run to generate R
code that defines these constants.
<r:code>
globalConstants = computeGlobalConstants(tu, gvars, defs = types)
</r:code>
The return value has two components: cmds and filenames.
The filenames indicate where the variable was defined.
</para>

<para>
For the moment, we are going to manually remove the database related
variables.  This is relatively easy to do as we just find the
variables that don't start with 'wx' or that starts with 'wxDB' and
then we can remove the corresponding entries in both the commands and
the file names.
<r:code>
i = grep("^wx", names(globalConstants$cmds))
j = grep("^wxDB", names(globalConstants$cmds))
i = setdiff(i, j)
globalConstants$cmds = globalConstants$cmds[i]
globalConstants$filenames = globalConstants$filenames[i]
</r:code>
</para>

<para>
We need this to ensure that we have the correct
#include directives when referring to them in C code.
The function <r:var>expandConstantIncludeFileNames</r:var>
arranges to search for these files within a directory and
its sub-directories and construct the approriate
strings for use in #include directives.
<todo>
Add an argument to control whether we find duplicates in different directories
and add those too.  e.g. textdlg.h in wx/ and wx/generic/
</todo>
<r:code>
includes = expandConstantIncludeFileNames(globalConstants$filenames, "/usr/local/include/wx-2.8/wx")
</r:code>
The order of these includes is important.  We have sorted them by
variable name and this may matter for some cases. Ideally, header
files would be self-consistent and not require gymnastics by the
users. But this is not always so easy.
</para>

<para>
The cmds field is a character vector with an element for each variable
defined.  These are sorted by name.  On ocassion, we have to do some
surgery on this vector to handle conditional definitions.  For
example, we might want use an #ifdef around one or more code elements.
The same applies to some of the #includes in the
<r:var>includes</r:var>.  This is the case <todo>Provide a function to
do this based on a pattern or a vector of variable names.</todo>
</para>


<para>
So given these computations, we can generate the
C code that in turn will generate the R code
to define these constants as R values.
We use <r:func>writeCode</r:func> for this
to leverage the method for the <r:class>ComputeConstants</r:class>
class which is the class of <r:var>globalConstants</r:var>.
Note that we add some other include files manually as we know
(by experiment) that we need them.
<r:code><![CDATA[
writeCode(globalConstants, "native", 
          file = "/tmp/wxConstants.cpp",
          includes = paste("<", c("wx/wx.h", "wx/toolbar.h", "wx/generic/textdlgg.h", includes), ">", sep = ""))
]]></r:code>
Then we can compile this with
<sh:code>
g++ -o wxConstants /tmp/wxConstants.cpp `wx-config --cflags --libs`
</sh:code>
<fix/>
<todo>We are having problems with wxEVT_COMMAND_TAB_SEL_CHANGED not being found by the linker.
It is in tabctrl.h  and that is included. 
</todo>
</para>

<para>
We now move on to dealing with enumerations.
<r:code>
enums = getEnumerations(tu, wxFiles, NULL)
enumDefs = computeGlobalEnumConstants(tu, enums, defs = types)
writeCode(anonEnums, "r", file = "/tmp/wxEnums.R")
</r:code>
<todo>Create variables for named enumerations too.</todo>
<todo>namespace associated with an enum.</todo>
<todo>NA's in the names</todo>
<todo>__ as leading names.</todo>
<todo>What about the C code for enumerations to create them? coerce them to the correct type?
Doesn't generate anything.
</todo>

</para>

<para>
Next we turn our attention to the values available in the C/C++ code
via the #define mechanism of the pre-processor.  We cannot get this
information from the TU file as the pre-processor has already
performed the text expansion by this point.  As a result, we currently
use heuristics to search the header files for these #define entries
and then try to make sense of the text.  This is quite primitive and
can be easily fooled.  For the wxWidgets code, however, 
it does pretty well.
</para>

<para>
There are several richer options.
One is to use the pre-processor directly
to output the collection of #define macros it has after
processing an entire file.
With the GNU cpp application, we can use flags of the form
<sh:code>
cpp -P -dM wx.cpp
</sh:code>
Ideally, we would be able to use -dD rather than -dM as
that would exlcude the built-in macro definitions
and also would give the ``processed'' or expanded values.
Unfortunately, this does not seem to be activated.
The function <r:func>getCppDefines</r:func> uses 
this  approach with -dM and excludes the built-in
values.
</para>
<para>
Another approach is to use libcpp in the GNU compiler
suite and apply the processor ourselves and read its
contents at the end of the basic steps. This gives
us more control over the output we can generate.
We can also get back the parsed expressions rather
than their string form.
</para>

<para>
<note><para>We have introduced another way to compute these also using the pre-processor directly.
See <r:func>getCppDefines</r:func>.</para>
</note>
The function is called <r:func>getDefineConstants</r:func>.  We tell
the directory in which to search for #define entries in the header
files.  We can also specify which files and how to do the initial
search.  Basically, it calls the system grep command and searches for
#define. It cleans up the lines by removing comments and then attacks
the #defines.  It only matches #defines where there are two elements
on the line after the #define (i.e. separated by white space).
<r:code>
defines = getDefineConstants(dir = "/usr/local/include/wx-2.8/wx")
</r:code>
</para>

<para>
For wxWidgets, we would want to catch bodies of 
macros that are simple strings but perhaps confused by a call to 
wxT to treat them appropriatel in different locales and character sets, etc.
We can do this with
<r:code>
defines = gsub("^(_T|wxT)\\((.*)\\)$", "\\1", defines)
</r:code>
</para>

<para>
<r:code>
q = getCppDefines("wxAll.h", "`wx-config --cflags`")
qq = processDefines(q, keepFlags = TRUE, headerIfDefPattern = "(^__|(^__?[_A-Z]+__|_H_{,2}|_H_BASE_)$)")
</r:code>
The regular expression 
is only applied to macros with no body and catches symbols that start with __ such as
__wchar_t__, __useconds_t_defined and __glibcxx_class_requires2(_a,_b,_c)
and also attempts to identify defines that
relate to avoiding repeated inclusion, e.g. of the
form 
<cpp:code>
#ifndef MYFILE_H
#define MYFILE_H
  real contents of myfile.h
#endif
</cpp:code>
</para>

<para>
The result in <r:var>qq</r:var> is a list
with (currently) 4 elements:
parameterizedMacros,
macros, flagDefinees and ignored.
The ignored ones are defintions we think are irrelevant.
These are the ones matched by our headerIfDefPattern regular expression.
We return them so that users can attempt to make sense
of them in a context-specific manner.
The flagDefines element contains the macros that had no body
but which were not matched by the headerIfDefPattern.
The value of each such element is TRUE which makes it easier
to generate a valid definition in R for that variable.
The macros and parameterizedMacros are the most pertinent for
our purposes. The elements are the definitions that have no parameters
and so are "constants".
The parameterizedMacros are the ones that are treated as functions,
i.e. are defined with a (). They may not have a parameter,
i.e. they may be simple macro "functions" with no inputs.
</para>

<para>
To turn this into usable definitions, we look first at the
non-parameterized values.  These are "constants".  One approach to
dealing with these is to optimistically assume the values are
legitimate R "expressions", i.e. literals or simple C code that is
compatible with evaluation in R. We can find out whether this is true
by attempting parse the values.
<r:code>
cmds = lapply(qq$macros, function(x) try(parse(text = x)))
</r:code>
We will see a flurry of errors streaming by on the console.
But of the 4605 defininitions in <r:expr>qq$macros</r:expr>,
how many were and were not succesfully parsed
<r:code>
table(sapply(cmds, class))
<r:output>
expression  try-error 
      3930        675 
</r:output>
</r:code>
In other words, we got 85% of them.
How many could be evaluated?
<r:code>
e = new.env()
cmds = lapply(names(qq$macros), 
               function(id) 
                 try(assign(id, 
                            eval(parse(text = qq$macros[id]), e), 
                            e)))
table(sapply(cmds, class))
<r:output>
character  function   integer   logical   numeric try-error 
       47         5       212         6      2089      2246 
</r:output>
</r:code>
Well the number goes way down to about 55%. Why?
Because some of these macros refer to the constants,
either macros or regular constants such as enums or const variables in the library.
We can work with both the symbolic form of the expression or the actual
evaluated version.
</para>

<para>
Note that some of the expressions evaluate to functions. How's this?
Macros such wxTRY expands to try,  and the macros stderr, stdout, stdin expand to
the C values of the same name.  And wxClose expands to close.
We can probably eliminate all of these.
<r:code>
discardMacros = c(discardMacros, c("wxClose", "stderr", "stdout", "stdin", "wxTry"))
</r:code>
</para>

<para>
For wxWidgets, at least, we discard macros with a name starting with _
or containing a $.  We also eliminate macros whose body contains a
';'. This is justified after examining the three.
Some of the problematic ones to parse have
operators such as &lt;&lt;.
Ones that have casts should be discarded.
<r:code>
pp = lapply(qq$macros, function(x) try(parse(text = x)))
perrs = sapply(pp, inherits, "try-error")
</r:code>
</para>

<para>
There are certain macros defined something of the form A|B|C or
(A|B|C) relating to bit-fields.  Again, we need to have processed the
definitions of the enumerations before attempting to evaluate these.
But we first want to identify these, and we can leave them in symbolic form
when generating the code for the target R package.
How do we identify them?
We remove any ( and ) at the beginning and end of all the macros
and then do a string split using | as the separator
Then, we look at the values which have more than one entry
<r:code>
tmp = strsplit(gsub("(^\\(|\\)$)", "", qq$macros), "|", fixed = TRUE)
bits = tmp[sapply(tmp, length) > 1]
bits = lapply(bits, trim)
</r:code>
Not all entries will be valid bitwise ORs.  For example, we have | in
the definition of wxALL_FILES - "gettext_noop(\"All files (*)|*\")".
We will detect this if we either find that the string is a literal
number or we look for the elements within our namespace of constants.
Alternatively, we can look for ( or * but generally we would have to
parse the expression which is what libcpp does for us.

We can then find all the references in the other macros, enumerations
and global variables.
<r:code>
ok = sapply(bits,
        function(x, globalNames) {
           i = grep("^(0x)?[[:digit:]]+L?", x, perl = TRUE)           
           if(length(i))
               x = x[-i]
           all(x %in% globalNames)
        }, c(unlist(lapply(enumDefs, function(x) names(x@values))), names(qq$macros), names(globalConstants$cmds)))
</r:code>
And we find the wxALL_FILES that is not a legitimate bitwise OR.

</para>

<para>
If we want to find out what #define's were omitted, we can use the
<r:arg>getSkipped</r:arg> parameter and specify a value of <r:true/>
and we get information about all the names, definitions and locations
of these.
What does this code miss?
<itemizedlist>
<listitem>
It ignores multi-line macros.  It is not clear what we would
do with them even if we could process them. These are
typically longer in content and so do not map to 
simple constants such as numbers or strings.
</listitem>
<listitem>
<para>
If <r:arg>keepFlags</r:arg> is <r:true/>, 
we turn simple macro definitions with no content,
e.g. of the form 

<cpp:code>
#define NAME
</cpp:code>
i.e. where there is no value,
into the equivalent of
<cpp:code>
#define NAME TRUE
</cpp:code>. 
These are often used conditionally to
specify a qualifier such as const or to export a symbol from a DLL in
a platform-specific manner.  These are also often used to avoid
recursive inclusion by putting a define at the top of a file, e.g.
<cpp:code>
#ifndef MY_FILE_H
#define MY_FILE_H
...
#endif
</cpp:code>
Again, these do not map to a constant in R.
We can often detect these recursive-include barriers
in project-specific  fashion. For wxWidgets, these
are often of the form
'_WX_file_name_H_' or '_WX_file_name_H'
or '_WX_file_name_H_BASE_'.
We can check this with
<r:code>
tt  = getDefines(dir = "/usr/local/include/wx-2.8/wx", getSkipped = TRUE)
headerPatterns = c("_WX_.*_H_*", "_WX_.*_H_BASE_*", "_.*H_*")
headerDefinePattern = paste("^(", paste(headerPatterns, collapse = "|"), ")$", sep = "")
headers = grep(headerDefinePattern, names(tt$defs))
names(tt$defs)[headers]
</r:code>
and we get 226 of these in total of the 839 that we skip.
And all of these have no value:
<r:code>
table(sapply(tt$defs[ headers ], length))
</r:code>
And to see if we have caught too many,
let's look at those that don't start with '_WX':
<r:code>
names(tt$defs)[headers][- grep("^_WX", names(tt$defs)[headers]) ]
</r:code>
</para>
</listitem>

<listitem>
We (perhaps)<todo>Add this or deal with it somehow</todo> ignore those with a ( in the name as these identify
macros that take inputs, i.e. that are "simple functions".
Looking at the non-header-inclusion related macros
we examine the names of the macros to see if it has a '(' in the name.
And with 
<r:code>
j = grep( "\\(", names(tt$defs)[ - headers ])
</r:code>
we see there are 517.
We may be interested in mapping these to functions in R
but they are generally not constants, for the most part.
However, there are cases when such 
"functions" are merely short hand ways of defining
other constants, e.g.
<cpp:code>
#define wxMAKE_VERSION_DOT_STRING(x, y, z) \
    wxSTRINGIZE(x) "." wxSTRINGIZE(y) "." wxSTRINGIZE(z)
</cpp:code>
which when the wxSTRINGIZE is expand turns into 
<cpp:code>
 "x" "." "y" . "z"
</cpp:code>
where the actual text given for x, y, z is used.  This illustrates how
we often use the macro mechanism to concatenate text and defines a
constant value.

Or the '(' is not after the name, but is a form of 
grouping within the value.
For example, in wx/version.h, we see
<cpp:code>
#define wxVERSION_NUMBER ( (wxMAJOR_VERSION * 1000) + (wxMINOR_VERSION * 100) + wxRELEASE_NUMBER )
</cpp:code>
This is a constant and the '(' is not in the name.
</listitem>
<listitem>
Excluding the header-inclusion-barries and those macros with '(' in the
name, for wxWidgets, we are left with
<r:code>
(names(tt$defs)[-headers])[-j]
<r:output>
 [1] "wxTheApp"                      "wxBU_ALIGN_MASK"              
 [3] "wxABORT_ON_CONFIG_ERROR"       "DBTABLE_DOT_H"                
 [5] "__cplusplus"                   "wxYES_NO"                     
 [7] "WXWPARAM"                      "WXLPARAM"                     
 [9] "_System"                       "wxDEFAULT_DIALOG_STYLE"       
[11] "wxDEFAULT_DIALOG_STYLE"        "_WX_ERROR_REMOVE"             
[13] "_WX_PTROP"                     "_WX_PTROP_NONE"               
[15] "wxARRAY_DEFAULT_EXPORT"        "wxARRAY_EMPTY_CMP"            
[17] "EMPTY_PARAMETER_VALUE"         "wxHAS_ICON_LOCATION"          
[19] "wxS_DEFAULT"                   "wxENUM_KEY_TYPE_DEFINED"      
[21] "FAR"                           "FAR"                          
[23] "EXPORT"                        "CALLBACK"                     
[25] "FAR"                           "EXPORT"                       
[27] "CALLBACK"                      "SQL_API"                      
[29] "wxLC_MASK_TYPE"                "wxLC_MASK_ALIGN"              
[31] "wxLC_MASK_SORT"                "wxLIST_HITTEST_ONITEM"        
[33] "wxENUM_KEY_TYPE_DEFINED"       "wxLIST_COMPATIBILITY"         
[35] "_WX_DELETEFUNCTIONCONST"       "wxLIST_COMPATIBILITY"         
[37] "WX_LIST_PTROP_NONE"            "WXDEBUG_DUMPDELAYCOUNTER"     
[39] "WXTRACE"                       "WXTRACELEVEL"                 
[41] "_WX_MINIFRAMH_BASE_"           "_WX_WANT_NEW_SIZET_WXCHAR_INT"
[43] "__WX_SCOPED_POINTER__"         "wxSP_3D"                      
[45] "WXSTRINGCAST"                  "wxCSTRINGCAST"                
[47] "wxMBSTRINGCAST"                "wxWCSTRINGCAST"               
[49] "wxDEFAULT_DELIMITERS"          "wxTR_DEFAULT_STYLE"           
[51] "wxTR_DEFAULT_STYLE"            "wxVERSION_STRING"             
[53] "wxABI_VERSION"                 "wxVERSION_NUMBER"             
[55] "wxVERSION_FLOAT"               "VMS_X_FIX"                    
[57] "EMPTY_MACROVALUE"              "WXZIPFIX"                     
</r:output>
</r:code>
Those that are empty are of no interest.
<r:code>
tmp = tt$defs[(names(tt$defs)[-headers])[-j]]
tmp[sapply(tmp, length) == 0]
<r:output>
$wxTheApp
[1] "((wxApp"                 "*)wxApp::GetInstance())"

$wxBU_ALIGN_MASK
[1] "("           "wxBU_LEFT"   "|"           "wxBU_TOP"    "|"          
[6] "wxBU_RIGHT"  "|"           "wxBU_BOTTOM" ")"          

$wxYES_NO
[1] "(wxYES" "|"      "wxNO)" 

$WXWPARAM
[1] "void" "*"   

$WXLPARAM
[1] "void" "*"   

$wxDEFAULT_DIALOG_STYLE
[1] "(wxCAPTION"   "|"            "wxMAXIMIZE"   "|"            "wxCLOSE_BOX" 
[6] "|"            "wxNO_BORDER)"

$wxDEFAULT_DIALOG_STYLE
[1] "(wxCAPTION"   "|"            "wxMAXIMIZE"   "|"            "wxCLOSE_BOX" 
[6] "|"            "wxNO_BORDER)"

$`_WX_ERROR_REMOVE`
[1] "wxT(\"removing"     "inexisting"         "element"           
[4] "in"                 "wxArray::Remove\")"

$`_WX_PTROP`
[1] "pointer"      "operator->()" "const"        "{"            "return"      
[6] "m_ptr;"       "}"           

$wxS_DEFAULT
[1] "(wxS_IRUSR" "|"          "wxS_IWUSR"  "|"          "wxS_IRGRP" 
[6] "|"          "wxS_IWGRP"  "|\\"       

$SQL_API
[1] "EXPORT"   "CALLBACK"

$wxLC_MASK_TYPE
[1] "(wxLC_ICON"      "|"               "wxLC_SMALL_ICON" "|"              
[5] "wxLC_LIST"       "|"               "wxLC_REPORT)"   

$wxLC_MASK_ALIGN
[1] "(wxLC_ALIGN_TOP"  "|"                "wxLC_ALIGN_LEFT)"

$wxLC_MASK_SORT
[1] "(wxLC_SORT_ASCENDING"  "|"                     "wxLC_SORT_DESCENDING)"

$wxLIST_HITTEST_ONITEM
[1] "(wxLIST_HITTEST_ONITEMICON"      "|"                              
[3] "wxLIST_HITTEST_ONITEMLABEL"      "|"                              
[5] "wxLIST_HITTEST_ONITEMSTATEICON)"

$WXTRACE
[1] "true"    "?"       "(void)0" ":"       "wxTrace"

$WXTRACELEVEL
[1] "true"         "?"            "(void)0"      ":"            "wxTraceLevel"

$wxSP_3D
[1] "(wxSP_3DBORDER" "|"              "wxSP_3DSASH)"  

$WXSTRINGCAST
[1] "(wxChar"  "*)(const" "wxChar"   "*)"      

$wxCSTRINGCAST
[1] "(wxChar"  "*)(const" "wxChar"   "*)"      

$wxMBSTRINGCAST
[1] "(char"    "*)(const" "char"     "*)"      

$wxWCSTRINGCAST
[1] "(wchar_t" "*)(const" "wchar_t"  "*)"      

$wxDEFAULT_DELIMITERS
[1] "(_T(\""        "\\t\\r\\n\"))"

$wxTR_DEFAULT_STYLE
[1] "(wxTR_HAS_BUTTONS" "|"                 "wxTR_NO_LINES)"   

$wxTR_DEFAULT_STYLE
[1] "(wxTR_HAS_BUTTONS" "|"                 "wxTR_NO_LINES)"   

$wxVERSION_STRING
[1] "_T(\"wxWidgets" "2.6.3\")"      

$wxABI_VERSION
 [1] "("               "wxMAJOR_VERSION" "*"               "10000"          
 [5] "+"               "wxMINOR_VERSION" "*"               "100"            
 [9] "+"               "99"              ")"              

$wxVERSION_NUMBER
 [1] "("                "(wxMAJOR_VERSION" "*"                "1000)"           
 [5] "+"                "(wxMINOR_VERSION" "*"                "100)"            
 [9] "+"                "wxRELEASE_NUMBER" ")"               

$wxVERSION_FLOAT
[1] "("                        "wxMAJOR_VERSION"         
[3] "+"                        "(wxMINOR_VERSION/10.0)"  
[5] "+"                        "(wxRELEASE_NUMBER/100.0)"
[7] "+"                        "(wxBETA_NUMBER/10000.0)" 
[9] ")"                       
</r:output>
</r:code>
The wx.*CAST entries are no interesting to us.
Same for SQL_API and _WX_PTROP and _WX_ERROR_REMOVE
and WXWPARAM.
And wxTheApp we can deal with manually, if we need it.
However, there are many entries that are 
actually bitwise OR's (|) of (presumably) existing pieces.
If we go back to the original lines (after removing the #define, trimming, etc.),
we get 
<r:code>
tmp = tt$defs[(names(tt$defs)[-headers])[-j]]
tmp = tmp[sapply(tmp, length) != 0]
tt$raw[match(names(tmp), names(tt$defs))]
<r:output>
 [1] "wxTheApp ((wxApp *)wxApp::GetInstance())"                                                                         
 [2] "wxBU_ALIGN_MASK      ( wxBU_LEFT | wxBU_TOP | wxBU_RIGHT | wxBU_BOTTOM )"                                         
 [3] "wxYES_NO                (wxYES | wxNO)"                                                                           
 [4] "WXWPARAM        void *"                                                                                           
 [5] "WXLPARAM        void *"                                                                                           
 [6] "wxDEFAULT_DIALOG_STYLE  (wxCAPTION | wxMAXIMIZE | wxCLOSE_BOX | wxNO_BORDER)"                                     
 [7] "wxDEFAULT_DIALOG_STYLE  (wxCAPTION | wxMAXIMIZE | wxCLOSE_BOX | wxNO_BORDER)"                                     
 [8] "_WX_ERROR_REMOVE wxT(\"removing inexisting element in wxArray::Remove\")"                                         
 [9] "_WX_PTROP pointer operator->() const { return m_ptr; }"                                                           
[10] "wxS_DEFAULT   (wxS_IRUSR | wxS_IWUSR | wxS_IRGRP | wxS_IWGRP |\\"                                                 
[11] "SQL_API                 EXPORT CALLBACK"                                                                          
[12] "wxLC_MASK_TYPE       (wxLC_ICON | wxLC_SMALL_ICON | wxLC_LIST | wxLC_REPORT)"                                     
[13] "wxLC_MASK_ALIGN      (wxLC_ALIGN_TOP | wxLC_ALIGN_LEFT)"                                                          
[14] "wxLC_MASK_SORT       (wxLC_SORT_ASCENDING | wxLC_SORT_DESCENDING)"                                                
[15] "wxLIST_HITTEST_ONITEM (wxLIST_HITTEST_ONITEMICON | wxLIST_HITTEST_ONITEMLABEL | wxLIST_HITTEST_ONITEMSTATEICON)"  
[16] "WXTRACE true ? (void)0 : wxTrace"                                                                                 
[17] "WXTRACELEVEL true ? (void)0 : wxTraceLevel"                                                                       
[18] "wxSP_3D               (wxSP_3DBORDER | wxSP_3DSASH)"                                                              
[19] "WXSTRINGCAST (wxChar *)(const wxChar *)"                                                                          
[20] "wxCSTRINGCAST (wxChar *)(const wxChar *)"                                                                         
[21] "wxMBSTRINGCAST (char *)(const char *)"                                                                            
[22] "wxWCSTRINGCAST (wchar_t *)(const wchar_t *)"                                                                      
[23] "wxDEFAULT_DELIMITERS (_T(\" \\t\\r\\n\"))"                                                                        
[24] "wxTR_DEFAULT_STYLE           (wxTR_HAS_BUTTONS | wxTR_NO_LINES)"                                                  
[25] "wxTR_DEFAULT_STYLE           (wxTR_HAS_BUTTONS | wxTR_NO_LINES)"                                                  
[26] "wxVERSION_STRING   _T(\"wxWidgets 2.6.3\")"                                                                       
[27] "wxABI_VERSION ( wxMAJOR_VERSION * 10000 + wxMINOR_VERSION * 100 + 99 )"                                           
[28] "wxVERSION_NUMBER ( (wxMAJOR_VERSION * 1000) + (wxMINOR_VERSION * 100) + wxRELEASE_NUMBER )"                       
[29] "wxVERSION_FLOAT ( wxMAJOR_VERSION + (wxMINOR_VERSION/10.0) + (wxRELEASE_NUMBER/100.0) + (wxBETA_NUMBER/10000.0) )"
</r:output>
</r:code>
In the case of the OR's, if we were to remove any leading ( and
trailing ) in the value of the macro and then strsplit based on
"\\s*\\|\\s*", then we would get a series of words and we could match
those against known enumeration identifiers and already resolved
#define constants and see if these can then be interpreted.
</listitem>
</itemizedlist>
</para>
<para>
There are #defines that do not map to a constant
that we do want to process.
For example, in the wxWidgets code, (specifically
in the file textctrl.h), we see
<cpp:code>
#define EVT_TEXT(id, fn) wx__DECLARE_TEXTEVT(UPDATED, id, fn)
</cpp:code>
If we resolve the definition of wx__DECLARE_TEXTEVT()
a few lines above, we see that this then calls
wx__DECLARE_EVT1 which is defined in a different file
and this chains its way through a collection of #defines.
</para>

<para>
When we have finished organizing the list of possible macros that we
want to consider, we can pass this to <r:func>filterDefines</r:func>.
This endeavors to process the actual definitions into R expressions
that can be evaluated and assigned to R variables with the same name
as the macro.
</para>

<para>
Why do we still need to remove duplicates?
<r:code>
dd = names(defines)[duplicated(names(defines))]
dups = lapply(dd, function(id)  defines[names(defines) == id])
dups = dups[sapply(dups, function(x) length(unique(x))) > 1]
</r:code>
</para>
</section>


<section>

<r:code id="tu">
wxFiles = list.files("/usr/local/include/wx-2.8/wx", recursive = TRUE)
</r:code>

<r:code id="tuGlobals">
gvars = getGlobalVariables(tu, names(wxFiles))
types = DefinitionContainer()
globalConstants = computeGlobalConstants(tu, gvars, defs = types)

enums = getEnumerations(tu, wxFiles, NULL)
enumDefs = computeGlobalEnumConstants(tu, enums, defs = types)
</r:code>

The following finds the macro definitions and
puts them into groups and filters out the ones we don't want.
The choice of filter is an argument to processDefines and
can be customized with a function or a list of functions
that are applied sequentially.
<r:code id="real">
<![CDATA[
q = getCppDefines("~/Projects/org/omegahat/R/RwxWidgets/src/wxAll.h", "`wx-config --cflags`")
qq = processDefines(q, keepFlags = TRUE, headerIfDefPattern = "(^__|(^__?[_A-Z]+__|_H_{,2}|_H_BASE_)$)")
]]>
</r:code>


These functions are now in the <r:pkg>RGCCTranslationUnit</r:pkg> package in defines.R
<r:function id="gsubset">
gsubset = 
function(x, pattern, useNames = FALSE, ...)
{
 i = grep(pattern, if(useNames) names(x) else x, ...)
 if(length(i) > 0)
   x = x[-i]

 x
}
</r:function>

<r:function id="filterMacros"><![CDATA[
filterMacros =
function(qq, namePatterns = c("^SQL", "pthread"), valuePatterns = c())
{
   # get rid of macros that are identity operations:
   # i.e. simply #define NAME NAME
qq$macros = qq$macros[ names(qq$macros) != qq$macros ]

 for(i in namePatterns)
   qq$macros = gsubset(qq$macros, i, TRUE, ignore.case = TRUE)
 for(i in valuePatterns)
   qq$macros = gsubset(qq$macros, i, FALSE)



 # Get rid of any macros that expand to the name of flagDefine which is nothing.
i = ( gsub("^`(.*)`", "\\1", qq$macros) %in% names(qq$flagDefines))
if(any(i))
 qq$macros = qq$macros[!i]


# remove surrounding () 
qq$macros = gsub("^\\((.*)\\)$", "\\1", qq$macros)


# XXX note the ignore.case.
#  qq$macros = gsubset(qq$macros, "pthread", TRUE, ignore.case = TRUE)

qq$macros = gsub("^([[:digit:]]+)l$", "\\1L", qq$macros)

qq$macros = gsub("^([[:digit:]]+)UL$", "\\1", qq$macros)
qq$macros = gsub("^([[:digit:]]+)LL$", "\\1", qq$macros)
qq$macros = gsub("^([[:digit:]]+)UL$", "\\1", qq$macros)

qq$macros = gsub("^(0x[[:xdigit:]]+)ul?$", "\\1", qq$macros)

# handle wxSOUND_ entries of the form (unsigned)digits by discarding the unsigned
#  and putting an L at the end.  Hope there isn't one there already.
qq$macros = gsub("^\\(unsigned\\)\\s*([[:digit:]]+)$", "\\1L", qq$macros)

qq$macros = gsubset(qq$macros,  "\\$", TRUE)
qq$macros = gsubset(qq$macros, "[a-zA-Z]\\.")  # anything with a . in the body

qq$macros = gsubset(qq$macros, "__asm __volatile")

# wxWidgets-specific dealing with strings.
# These next two are very similar the first just having a () around the entire expression.
qq$macros = gsub("^\\(?(_T|wxT)\\((.*)\\)\\)$", "\\2", qq$macros)
qq$macros = gsub("^(_T|wxT)\\((.*)\\)$", "\\2", qq$macros)
qq$macros = gsub("^wxString\\((_T|wxT)\\((.*)\\)\\)$", "\\2", qq$macros)

qq$macros = gsub("^gettext_noop\\((.*)\\)$", "\\1", qq$macros)

# for values of macros that are names, protect them as R variables by back-quoting.
qq$macros = gsub('^(_+[A-Za-z][_A-Za-z0-9]*)$', "`\\1`", qq$macros)

 # Get rid of any macros with a ; - multiple commands.
qq$macros = gsubset(qq$macros, ';')

 # Look for macro definitions with << or >> 
shifts = grep("(<<|>>)", gsub("(^\\(|\\)$)", "", qq$macros))
if(length(shifts))  {
   qq$calculate = c(qq$calculate, qq$macros[shifts])
   qq$macros = qq$macros[ - shifts]
}

# Find macros of the form (a|b...) and move them from macros to calculate
# as we "need" to evaluate them.

tmp = strsplit(gsub("(^\\(|\\)$)", "", qq$macros), "|", fixed = TRUE)
i = sapply(tmp, length) > 1
if(length(i)) {
  qq$calculate = c(qq$calculate, qq$macros[i])
  qq$macros = qq$macros[-i]
#XXX wxWidgets-specific
  i = match("wxALL_FILES", names(qq$calculate))
  if(!is.na(i)) {
     qq$macros["wxALL_FILES"] = qq$calculate["wxALL_FILES"]
     qq$calculate = qq$calculate[-i]
  }
}

 # Now see which macro definitions we can parse
pp = lapply(qq$macros, function(x) try(parse(text = x), TRUE))
qq$macros = qq$macros[ ! sapply(pp, inherits, "try-error") ]


  # Remove the macros which correspond to calls but which are not simple arithmetic or logical operators.
pp = pp[ ! sapply(pp, inherits, "try-error") ]

mtypes = sapply(pp, function(x) class(x[[1]]))
tmp = sapply(pp[mtypes == "call"], function(x) as.character(x[[1]][[1]])[1] %in% c("|", "-", "/", "+", "*"))
callNames = names(mtypes)[mtypes == "call"]

  # put the call macros we want into qq$calculate
qq$calculate = c(qq$calculate, qq$macros[ callNames[tmp] ])
  # and discard all of the call macros from qq$macros
qq$macros = qq$macros[ - match(callNames, names(qq$macros), 0) ]


       # Also look in the names of the C++ classes as this would get, e.g.,
       #  wxDirCtrl which is mapped to wxGenericDirCtrl. But that is just an alias,
       # and not vital.
if(FALSE && !exists("wxClasses"))
   system.time(wxClasses <- getClassNodes(tu, wxFiles, validateSource = isSourceFile))
# names(wxClasses),

makeFactor = 
function(..., labels = LETTERS[length(els)])
{
  els = list(...)
  ans = factor(unlist(lapply(seq(along = els), function(i) rep(labels[i], length(els[[i]])))))
  names(ans) = unlist(els)
  ans
}

   # Note that there is one symbol - MSG_TRYHARD - that is both an enum and a macro.
   # we don't need to have this as a factor, but it is convenient when debugging so that
   # we can easily find out where the variables are defined
globalDefNames = makeFactor(names(globalConstants$cmds), unlist(lapply(enumDefs, function(x) names(x@values))),
                             names(qq$macros), names(qq$calculate), names(qq$flagDefines), 
                            labels = c("Variable", "Enum", "Macro", "Calculate", "MacroFlag"))


varRefs = names(mtypes)[mtypes == "name"]
   # have to undo the `` quoting
i = gsub("^`(.*)`$", "\\1", qq$macros[varRefs]) %in% names(globalDefNames)
vals = qq$macros[varRefs[i]]
out = qq$macros[varRefs[!i]]
  # move these to calculate
#NO: qq$calculate = c(qq$calculate, vals)
  # get rid of all the macros that refer to a variable name
qq$macros = qq$macros[ - match(varRefs, names(qq$macros), 0) ]
  # put at the end to avoid dependency/ordering issues.
qq$macros = c(qq$macros, vals)


  # find cases where the value of one macro is the name
  # of a macro we are omitting.
  # need to iterate as if we remove a macro
while(length(out)) {
     i = ( gsub("^`(.*)`", "\\1", qq$macros) %in% names(out))
     if(any(i)) {
        out = qq$macros[i]
        qq$macros = qq$macros[!i]
     } else
        out = character()
}

 qq = reorderMacros(qq)
 
 qq
}
]]>
</r:function>

Reorder the macro definitions to make certain that any references within 
a macro to another macro come after the RHS is defined. We just do this for the simple macros
that are of type "name", i.e. just a symbol referencing the other macro.
We find the indices of the definitions that are simple names.
<!-- These are in defines.R now. -->
<r:function id="reorderMacros"><![CDATA[
reorderMacros =
function(qq)
{
 types = sapply(qq$macros, function(x) class(parse(text = x)[[1]]))
 named = qq$macros[types == "name"]


 pos.lhs = structure( match( names(named), names(qq$macros)), names = names(named) )
 pos.lhs = pos.lhs[!is.na(pos.lhs)]
 pos.rhs = structure(match(gsub("`(.*)`", "\\1", named), names(qq$macros)), names = names(named))
 pos.rhs = pos.rhs[!is.na(pos.rhs)]
 toFix = names(which(pos.lhs < pos.rhs[names(pos.lhs)]))
 if(length(toFix)) {
    i = match(toFix, names(qq$macros))
    qq$macros = c(qq$macros[-i], qq$macros[sort(i)])
 }

 qq
}
]]></r:function>

Parameterized macros
<r:code>
simpleFunctionCalls = grep("\\w\\s*\\((\\w(, ?)?)*\\)", qq$parameterizedMacros)
</r:code>

<r:code id="output">
<![CDATA[
wxEnums.R = paste(autoGenerateDir, "..", "R", "wxEnums.R", sep = .Platform$file.sep)
con = file(wxEnums.R, "w")
invisible(
sapply(enumDefs,
        function(x) {
           if(length(x@values))
              cat(paste(paste("`", names(x@values), "`", sep = ""), " = ", x@values, ifelse(is.na(x@values), "", "L"), sep = ""), "\n", sep = "\n", file = con)
        }))

code = sapply(names(qq$macros), function(id) paste("`", id, "`",  " = ", qq$macros[id], sep = ""))
cat(code, "\n", sep = "\n", file = con)
close(con)


# Generate the C code that generates the R code defining the 
# variables in qq$calculate
wxDefines.cpp = paste(autoGenerateDir, "..", "inst", "src", "wxDefines.cpp", sep = .Platform$file.sep)
cdefs = file(wxDefines.cpp, "w")
cat("#include <stdio.h>",
    '#include "wxAll.h"',
    "int",
    "main(int argc, char *argv[])",
    "{",
    sep = "\n", file = cdefs)

invisible(
sapply(names(qq$calculate),
       function(id) {
          cat('printf("`', id, '` = %d\\n", (int) ', qq$calculate[id], ');\n', sep = "", file = cdefs)
       }))

cat("return(0);",
    "}\n", sep = "\n", file = cdefs)
close(cdefs)

]]>
</r:code>



For testing the output is okay.
<r:code id="test">
# Compile the wxGlobals 
system(paste("g++ -o /tmp/wxLiterals -I$OMEGA_HOME/R/RwxWidgets/src `wx-config --cflags --libs`", wxDefines.cpp))
eval(parse(text = system("/tmp/wxLiterals", intern = TRUE)))


o = sapply(readLines(wxEnums.R), function(x) try(eval(parse(text = x), globalenv())))
problems = gsub("^`(.*)` =.*$", "\\1", names(o[sapply(o, inherits, "try-error")]))
v = gsub("^`.*` = (.*)$", "\\1", names(o[sapply(o, inherits, "try-error")]))
</r:code>


A little function for chasing down the definition of a
macro whose body is the value of another macro and so on.
This is useful for finding the definition of the macros
whose names are in <r:var>problems</r:var>.
<r:code>
chaseDef =
function(id, macros)
{
 path = character()
 while(!is.na(id)) {
   id = gsub("`(.*)`", "\\1", id)
   path = c(path, id)
   val = macros[id]
   id = val
 }

# names(path)[1] = path[1]

 path[-1]
}
</r:code>


The remaining 91 values that we cannot parser are not very important.
They are named
<r:code>
pp = lapply(qq$macros, function(x) try(parse(text = x)))
perrs = qq$macros[sapply(pp, inherits, "try-error")]
names(perrs)
<r:output>
 [1] "__NFDBITS"                        "__UINTMAX_TYPE__"                
 [3] "__WAIT_STATUS"                    "__WAIT_STATUS_DEFN"              
 [5] "wxWCSTRINGCAST"                   "wxSOUND_SYNC"                    
 [7] "__U16_TYPE"                       "WX_STATFS_T"                     
 [9] "_Mlong_double_"                   "HUGE_VAL"                        
[11] "__SIZE_TYPE__"                    "__UWORD_TYPE"                    
[13] "__WINT_TYPE__"                    "__S16_TYPE"                      
[15] "MB_CUR_MAX"                       "RTLD_DEFAULT"                    
[17] "_IO_stdin"                        "__U32_TYPE"                      
[19] "__attribute_deprecated__"         "wxCSTRINGCAST"                   
[21] "__CONST_SOCKADDR_ARG"             "__PTRDIFF_TYPE__"                
[23] "_G_HAVE_ST_BLKSIZE"               "__TFILE__"                       
[25] "wxSOUND_LOOP"                     "HUGE_VALF"                       
[27] "HUGE_VALL"                        "SQL_API"                         
[29] "__END_DECLS"                      "__SOCKADDR_ARG"                  
[31] "WEOF"                             "INFINITY"                        
[33] "wxWC2WXbuf"                       "wxSOUND_ASYNC"                   
[35] "_SIGSET_NWORDS"                   "WXDEBUG_NEW"                     
[37] "ULONG_MAX"                        "__ULONGWORD_TYPE"                
[39] "wxStructStat"                     "ULLONG_MAX"                      
[41] "__U64_TYPE"                       "__BEGIN_DECLS"                   
[43] "WX_BUILD_OPTIONS_SIGNATURE"       "__ULONG32_TYPE"                  
[45] "__S64_TYPE"                       "__SQUAD_TYPE"                    
[47] "__ASSERT_VOID_CAST"               "__always_inline"                 
[49] "ULONG_LONG_MAX"                   "S_IRWXU"                         
[51] "__attribute_used__"               "NAN"                             
[53] "__FLT_EPSILON__"                  "SQL_ODBC_KEYWORDS"               
[55] "__TDATE__"                        "__LONG_LONG_MAX__"               
[57] "__INTMAX_TYPE__"                  "__WX_BO_COMPILER"                
[59] "__attribute_pure__"               "wxWrite"                         
[61] "UINT_MAX"                         "LC_GLOBAL_LOCALE"                
[63] "__ptr_t"                          "__TIMER_T_TYPE"                  
[65] "__TTIME__"                        "WXTRACELEVEL"                    
[67] "__FLT_MAX__"                      "__SWORD_TYPE"                    
[69] "_IO_stdout"                       "__attribute_noinline__"          
[71] "__NCPUBITS"                       "wxMBSTRINGCAST"                  
[73] "__FLT_MIN__"                      "__flexarr"                       
[75] "__UQUAD_TYPE"                     "wxWX2WCbuf"                      
[77] "_IO_stderr"                       "WXSTRINGCAST"                    
[79] "__SOCKADDR_COMMON_SIZE"           "wxULongLong_t"                   
[81] "RTLD_NEXT"                        "__SLONGWORD_TYPE"                
[83] "HUGE"                             "__UNKNOWN_10646_CHAR"            
[85] "LONG_LONG_MIN"                    "__attribute_warn_unused_result__"
[87] "WXTRACE"                          "wxConvFile"                      
[89] "__long_double_t"                  "wxRead"                          
[91] "wxSTD"                            "_SS_PADSIZE"                     
[93] "__FLT_DENORM_MIN__"               "wxTheApp"                        
[95] "__attribute_malloc__"            
</r:output>
</r:code>
Many of these are synonyms for various C types
and casts from one C type to another.

The wx-related ones  are
<r:code>
grep("^wx", names(perrs), value = TRUE)
<r:output>
 [1] "wxWCSTRINGCAST" "wxSOUND_SYNC"   "wxCSTRINGCAST"  "wxSOUND_LOOP"  
 [5] "wxWC2WXbuf"     "wxSOUND_ASYNC"  "wxStructStat"   "wxWrite"       
 [9] "wxMBSTRINGCAST" "wxWX2WCbuf"     "wxULongLong_t"  "wxConvFile"    
[13] "wxRead"         "wxSTD"          "wxTheApp"      
</r:output>
</r:code>
wxConvFile and the wxSOUND_ macros are the only ones that look somewhat useful.
The sound ones are simple numbers that cannot be parsed because of
casts. They are of the form (unsigned)digit.
These are now dealt with.

We can handle macros whose names start with _ using
explicit assignment or backticks.

Eliminate macros with a body that contains a .
Although we could turn this into a $ if it was a global variable.

<para>
Now, we can look at how the macros are parsed.
We don't need to evaluate them, just parse them.
<r:code>
pp = lapply(qq$macros, function(x) try(parse(text = x)))
</r:code>
Then, look at the resulting expression and see what types they are.
<r:code>
types = sapply(pp, function(x) class(x[[1]]))
table(types)
<r:output>
     call character   integer      name   numeric 
      183        21       243      1797      1962 
</r:output>
</r:code>

It is the call elements  that are interesting to us
as the rest are easy to deal with since they are literals
or the values of other variables/defines.
We look at the nature of the call, specifically the
first element and we turn it into a string.
This will expand expressions of the form wxClass::method into
a character vector with three elements - ::, wxClass, method.
So we look only at the first one.
<r:code>
x = sapply(pp[types == "call"], function(x) as.character(x[[1]][[1]])[1] %in% c("|", "-", "/", "?", "+", "*"))
</r:code>

</para>

</section>
</article>